// 	value_category_tester.hpp
#ifndef INCLUDE_GUARDS_value_category_tester_HPP
#define INCLUDE_GUARDS_value_category_tester_HPP
/*
	Дэвид Вандевурд, Николаи М. Джосаттис, Дуглас Грегор Шаблоны C++. Справочник разработчика, 2-е издание - 2018
	
	Бьярне Страуструп "ПРОГРАММИРОВАНИЕ, принципы и практика использования С++", Исправленное издание.
	
	https://habr.com/ru/articles/441742/
	
	https://medium.com/@barryrevzin/value-categories-in-c-17-f56ae54bccbe
	Barry Revzin
*/
#include	<iostream>
using std::cout; using std::endl;
#include	<string>
#include	<type_traits>
#include	<utility>
#include "../color_output.hpp"
using namespace color_output;

namespace	chat_gpt_seh
{
/*
	`Категории выражений` в `C++`

	"Категории выражений", такие как `l-value` и `r-value`, 
	относятся, скорее, к `фундаментальным теоретическим понятиям` языка `C++,` 
	чем к практическим аспектам его использования.
	
	В основу новой более строгой терминологии легли 2 свойства:

	-	наличие идентичности (identity) 					– 	т.е. какого-то параметра, по которому можно понять, 
															'ссылаются' ли 
															'два' "выражения" 
															'на одну и ту же' "сущность" 
															или нет 
															(например, адрес в памяти);
												
	-	возможность перемещения (can be moved from) 	– 	поддерживает 'семантику перемещения'.

	Обладающие 'идентичностью' выражения 
	обобщены под термином `gl-value` (generalized `l-value`s), 	/generalized - обобщенный/
	
	'перемещаемые' выражения называются `r-value`. 
	
	Комбинации двух этих свойств определили 3 'основные категории' (`l-value`, `x-value`, `pr-value`)
	и 2 'составные категории' (`gl-value`, `r-value`) "выражений":

	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									Обладают идентичностью				Лишены идентичности
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	Не могут быть перемещены		`l-value`								–
	
	Могут быть перемещены			`x-value`							`pr-value`				->  `r-value`
	
									|
									V
									
									`gl-value	`
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	`l-value`		-	от (ранее - left, 
						сейчас - locator)		
							Стандарт `C89` определял `l-value` как 'object locator', 
							т.е. объект с 'идентифицируемым' местом в памяти.	
											-	'обладает идентичностью' и 'HE может быть перемещен'
											
	`x-value` 	-	от (an “eXpiring” value)	-	`истекающий срок жизни` - 
												'обладает идентичностью' и 'может быть перемещен'
												
												Объекты, 'срок жизни которых истекает', 
												"обладают идентичностью" и "могут быть перемещены".
												
	`pr-value`	-	от (a “pure” `r-value`)		-	чистый - и 'нет идентичности' и 'может быть перемещен'	
	
												То есть, "лишенные идентичности" объекты 
												обязательно обладают свойством "быть перемещенными".
												
												'Безымянные объекты' всегда "могут быть перемещены".
		
	В `современном Стандарте` `C++` "структура категорий" приводится в виде вот такой схемы:
	
						 КАТЕГОРИИ ВЫРАЖЕНИЙ	
						 
						   Value Categories		
						   
						`gl-value`	  `r-value`
						
						/		 \	  /		 \
						
				  `l-value`	  	`x-value`	`pr-value`
				  
	********************************************************	 `gl-value`

	Выражения категории `gl-value` обладают следующими свойствами:

	-	могут быть неявно преобразованы в `pr-value`;
	
	-	могут быть полиморфными, т.е. 
		для них имеют смысл понятия `статического` и `динамического` типа;
		
	-	не могут иметь тип `void` – это напрямую следует из свойства `наличия идентичности`, 
		ведь для выражений типа `void` нет такого параметра, 
		который позволил бы отличать их одно от другого;
		
	-	могут иметь 'неполный тип' (incomplete type), 
		например, в виде 'forward declaration' (если это разрешено для конкретного выражения).
	
	К категории `gl-value` относятся выражения,
	являющиеся `l-value` или `x-value`.
	
	********************************************************	 `r-value`

	Выражения категории `r-value` обладают следующими свойствами:

	-	`не могут` находиться `в левой` части `оператора присваивания` или `составного присваивания`;
	
	-	могут использоваться для "инициализации" 
		константной `l-value`-ссылки или `r-value`-ссылки, 
		при этом `время жизни` объекта `расширяется до времени жизни ссылки`;
		
	-	если используются как аргумент при вызове функции, 
		у которой есть 2 перегруженные версии: 
		
		одна принимает константную `l-value`-ссылку, 
		а другая – `r-value`-ссылку, 
		то выбирается версия, принимающая `r-value`-ссылку. 
		
		Именно это свойство используется 
		при реализации `семантики перемещения` (`move semantics`).
		
	К категории `r-value` относятся следующие выражения,
	являющиеся `pr-value` или `x-value`:	
	
	-	чисто математические значения (например, 7 или символ 'а'), 
		которые не обязательно имеют связанное с ними место хранения;
		они существуют только для вычислений, 
		но после того, как они были использованы, 
		на них нельзя ссылаться. 
	
	- 	любые `литеральные значения`, за исключением `строковых литералов` 
		(например, 7, 'а', true, nullptr), являются r-значениями, 
		как и результаты многих встроенных арифметических вычислений
		(например, х + 5 для `х` целочисленного типа).

	-	вызовов функций, возвращающих результат "по значению". 
	
	-	все `временные значения` являются `r-значениями`.
		(Хотя это не относится к именованным ссылкам, которые ссылаются на них.)

	********************************************************	`l-value`

	Свойства:

	-	все свойства `gl-value` (см. выше);
	
	-	можно `взять адрес` (используя встроенный `унарный оператор &`);
	
	-	модифицируемые `l-value` могут находиться в левой части оператора присваивания 
		или составных операторов присваивания;
		
	-	могут использоваться для инициализации ссылки на `l-value` 
		(как константной, так и неконстантной).

	К категории `l-value` относятся следующие выражения:

	-	`имя переменной`, `функции` или `поле класса` любого типа. 
	
		Даже если 'переменная' является `r-value`-ссылкой, 
		'имя этой переменной' в выражении является `l-value`;

	-	вызов функции или перегруженного оператора, 
		возвращающего `l-value`-ссылку, 
		либо выражение преобразования к типу `l-value`-ссылки;
		
	-	`встроенные операторы присваивания`, 
		составные операторы присваивания (=, +=, /= и т. д.), 
		`встроенные преинкремент` и `предекремент` (++a, --b), 
		`встроенный оператор разыменования указателя` (*ptr);
		
	-	`встроенный оператор обращения по индексу` (a[n] или n[a]), 
		когда один из операндов – `l-value` массив;
		
	-	вызов функции или перегруженного оператора, 
		возвращающего `r-value`-ссылку на функцию;

	-	строковый литерал, например "Hello, world!".

		`Строковый литерал` отличается от всех остальных литералов в языке C++ именно тем, 
		что является `l-value` (хотя и неизменяемым). 
		
		Например, можно получить его адрес:

		auto * 	ptr = &”Hello, world!”; 			// 	тут `константный указатель`, на самом деле

	********************************************************		`x-value`

	Свойства:

	-	все свойства `r-value` (см. выше);
	
	-	все свойства `gl-value` (см. выше).

	Примеры выражений категории `x-value`:

	-	вызов функции или встроенного оператора, 
		возвращающего `r-value`-ссылку, 
		например std::move(x);

		и в самом деле, для результата вызова std::move() 
		нельзя получить адрес в памяти 
		или 
		инициализировать им ссылку, 
		
		но в то же время, это выражение может быть полиморфным.
		
	-	встроенный оператор обращения по индексу (a[n] или n[a]), 
		когда один из операндов – `r-value`-массив.	
		
	********************************************************	  `pr-value`

	Свойства:

	-	нельзя получить адрес `pr-value` в памяти – 
		это напрямую следует из свойства отсутствия идентичности;

	-	все свойства `r-value` (см. выше);
	
	-	не могут быть полиморфными: статический и динамический типы выражения всегда совпадают;
	
	-	не могут быть неполного типа (кроме типа 'void', об этом будет сказано ниже);

	-	не могут иметь абстрактный тип или быть массивом элементов абстрактного типа.

	К категории 'pr-value' относятся следующие выражения:

	-	литерал (кроме строкового), например `42`, `true` или `nullptr`;
	
	-	вызов функции или перегруженного оператора, 
		который возвращает не ссылку 
		
		(str.substr(1, 2), str1 + str2, it++) 
		
		или выражение преобразования к нессылочному типу 
		
		(например static_cast<double>(x), std::string{}, (int)42);
		
	-	`встроенные постинкремент` и `постдекремент` (a++, b--), 
		`встроенные математические операции` (a + b, a % b, a & b, a << b, и т.д.), 
		`встроенные логические операции` (a && b, a || b, !a, и т.д.), 
		`операции сравнения` (a < b, a == b, a >= b, и т.д.), 
		`встроенная операция взятия адреса` (&a);

	-	указатель `this`;

	-	`элемент перечисления`;

	-	`нетиповой параметр шаблона`, если он – не класс;
	
	-	`лямбда-выражение`, например [](int x){ return x * x; }.

	******************************************************************************************************
*/
/*
	"Категории значений выражения" отражены в системе типов. 
	
	Стандарт предоставляет 
	метод определения "категории значения выражения" 
	с помощью 'decltype'. 
	
	Учитывая выражение, 'expr' мы можем наблюдать тип decltype((expr))
	(лишние `круглые скобки` `не являются опечаткой`!). 
	
	Если этот результирующий тип 'является ссылочным типом' `l-value`, 
	выражение является `l-value`. 
	
	Если этот результирующий тип 'является ссылочным типом' `r-value`, 
	выражение является `x-value`. 
	
	В противном случае (если результирующий тип 'не является ссылочным типом') 
	выражение является значением `pr-value`. 
	
	Например:

	Только `r-value` могут привязываться к 'ссылкам r-value', 
	только 'неконстантные `l-value`' могут привязываться к 'ссылкам `l-value`' 
	(единственным исключением здесь является то, 
	что 'константныe `r-value`' действительно могут привязываться к 'ссылкам `l-value`', 
	что Херб Саттер называет наиболее важным `const`). 
	
	Это позволяет нам различать в системе типов `l-value` и `r-value` 
	(чтобы было понятно, 
	когда ресурсы объекта 
	можно безопасно использовать, 
	или когда их необходимо скопировать), 
	но 
	нет способа различать `x-value` и `pr-values`​
	при разрешении перегрузки. 
	
	Действительно, такая дифференциация, вероятно, в любом случае не будет полезной.
*/
/*
	*********************	value_category_tester	*******		value_category		**************
	
	Функция, 
	анализирующая выражение 
	на предмет принадлежности его 
	к той или иной 'категории значений'.
*/
/*
	Функция должна вернуть инофрмацию в виде строк с одним из следующих значений:
	"gl-value", "r-value", "l-value", "xvalue", "pr-value"
	
	Вызов функции дожен иметь следующий синтаксис:
	
	auto 			expr_value_cat 	= 	value_category_tester<decltype((test_variable))>();
	
	!!!!!!! (лишние круглые скобки не являются опечаткой!) !!!!!!
	корректно работает только при вызове с T = decltype((expr))
*/
/*
	The advice by ChatGPT!
	
	5. Рекомендую добавить мини-таблицу преобразований для пользователя

	Чтобы Ваш заголовок стал полностью самодостаточным:
	
	-----------------------------------------------------------------------------
	expr                   	decltype(expr)    	decltype((expr))
	-----------------------------------------------------------------------------
	x                     	int                		int&
	(x)                   	int                		int&
	std::move(x)          int&&              	int&&
	42                    	int                		int
	f() returns T         	T                  		T
	-----------------------------------------------------------------------------
	Это очень помогает понять, почему нужны двойные скобки.
*/
/*	
	Информация о принадлежности к категориям значений, 
	возвращается как "упорядоченная пара"
	
	std::pair<std::string, std::string>;
	
	Первый элемент возвращает 'основную категорию' ("l-value", "xvalue", "pr-value") - based category
	втoрой элемент пары несет в себе 'составную катеогрию' ("gl-value", "r-value") - composite category.
*/
using pair_return_type	=	std::pair<std::string, std::string>;

template <typename T>
pair_return_type 	value_category_tester() 
{
	cout << bright_white << "-------------- I'm value_category_tester()" << reset << endl;

	pair_return_type		result = {"", ""};
		
	//	------------------------------------------------------------------------------------------------------------------------------
	// 	"Основные категории"
	// 	Если 'T' является 'ссылочным типом `l-value`', выражение является `l-value`. 
	if (std::is_lvalue_reference_v<T>) {
		result.first	=	"l-value";
	}	
	// 	Если 'T' является 'ссылочным типом `r-value`', выражение является `x-value`. 
	else if (std::is_rvalue_reference_v<T>) {
		result.first	=	"x-value";
	}	
	// 	В противном случае (если результирующий тип "не является ссылочным типом") 
	// 	выражение является значением `pr-value`. 	
	else if (!std::is_reference_v<T>) {
		result.first	=	"pr-value";
	}	
	else {
		result.first	=	"indefinite";
	}
	//	-------------------------------------------------------------------------------------------
	// 	"Cоставные категории"			`: yes` - the advice by ChatGPT
	if (result.first == "pr-value") {
        result.second = "r-value: yes";           		// 	pr-value всегда r-value
	}	
    else if (result.first == "l-value") {
        result.second = "gl-value: yes";          		// 	l-value всегда gl-value
	}	
    else if (result.first == "x-value") {
        result.second = "gl-value: yes, r-value: yes";		// 	x-value принадлежит обеим категориям
	}	
    else {
        result.second = "indefinite";
	}
	return result;
}
//	-------------------------------------------------------------------------------------------
//	Имя функции, которое я придумал, оказалось слишком длинным

// 	Определим псевдоним с именем функции покороче	-	`value_category`

// 	Это трюк, так как используется синтаксис 'ссылки на функцию' с инициализацией
template<typename T>
pair_return_type(&value_category)() = value_category_tester<T>;
/*
	Вызов функции дожен иметь следующий синтаксис:
	
	auto 			expr_value_cat 	= 	value_category<decltype((test_variable))>();
	
	!!!!!!! (лишние круглые скобки не являются опечаткой!) !!!!!!
	корректно работает только при вызове с T = decltype((expr))
	
	-----------------------------------------------------------------------------
	expr                   	decltype(expr)    	decltype((expr))
	-----------------------------------------------------------------------------
	x                     	int                		int&
	(x)                   	int                		int&
	std::move(x)          int&&              	int&&
	42                    	int                		int
	f() returns T         	T                  		T
	-----------------------------------------------------------------------------
*/
/*
	The advice by ChatGPT!
	
	Псевдоним-функция выглядит громоздко!
	
	Это законно, но выглядит как «трюк ради трюка».

	Лучше сделать using `шаблон переменной`:
*/
#if 0
template<typename T>
constexpr auto value_category_chgpt = value_category_tester<T>();
//	
/*
	Не пошел этот шаблон :(
	
	Переменная `constexpr` в C++ должна иметь `литеральный` тип, 
	быть инициализирована во время компиляции 
	и инициализирующее значение или конструктор 
	должны быть константными выражениями.
	
	auto 			cat 				= 	value_category_chgpt<decltype((test_variable))>;
	
	Без () в конце инструкции - и работает как настоящая `compile-time` переменная.
*/
#endif	

// 	Можно использовать функцию ниже для вывода отладочной информации о `категории значений`
inline
void cout_test_result(const std::pair<std::string, std::string> 	_parametr)
{
	cout 	<< bright_white << "-------- I'm cout_test_result(const std::pair<std::string, std::string> _parametr)" 
			<< reset << endl;
	cout << "Категория основная (based): " << yellow << _parametr.first << reset 
		<< ". Категория составная (composite): " << green << _parametr.second << reset << endl;
}
/*
	Вызовы функции ((правильные)):
*/
#if 0	
	cout_test_result(value_category<decltype((test_variable))>());				//	Скобки () после <>
	
	cout_test_result(value_category_tester<decltype((test_variable))>());		//	Скобки () после <>
#endif	
/*
	The advice by ChatGPT!

	И добавить пример `неправильного` вызова:

	Иначе юзеры начнут ошибаться.
*/
#if 0	
// 	НЕ выражение, а тип → всегда `pr-value`
value_category<int>();        	

// 	Тоже неверно: `test_variable` без двойных круглых скобок ⇒ `pr-value`
value_category<decltype(test_variable)>();

// 	Правильно	`test_variable` в `двойных` круглых скобках ((test_variable))
value_category<decltype((test_variable))>(); 	
#endif	

/*
	The advice by ChatGPT!
	
	4. 	Вы предлагаете `строковый вывод` - было бы полезно добавить `compile-time` проверку
*/
template<typename T>
constexpr bool is_lvalue_expr_v 				= 	std::is_lvalue_reference_v<T>;
//	Это позволит делать:
#if 0	
static_assert(is_lvalue_expr_v<decltype((x))>);
#endif	
//	Развитие идеи

// 	Если 'T' является 'ссылочным типом `l-value`', выражение является `l-value`. 
// 	`l-value` всегда `gl-value`
template<typename T>
constexpr bool is_glvalue_expr_v 				= 	std::is_lvalue_reference_v<T>;

// 	Если 'T' является 'ссылочным типом `r-value`', выражение является `x-value`. 
template<typename T>
constexpr bool is_xvalue_expr_v 				= 	std::is_rvalue_reference_v<T>;
// 	`x-value` принадлежит обеим категориям: `gl-value` and `r-value`
template<typename T>
constexpr bool is_glvalue_and_rvalue_expr_v 	= 	std::is_rvalue_reference_v<T>;

// 	`pr-value` всегда `r-value`		и это не ссылочный тип
template<typename T>
constexpr bool is_prvalue_expr_v				=	!std::is_reference_v<T>;
template<typename T>
constexpr bool is_rvalue_expr_v				=	!std::is_reference_v<T>;

//	--------------------------------------------------------------------------------------------------------
};	//	End of the 	namespace	chat_gpt_seh;
//	--------------------------------------------------------------------------------------------------------
#endif	//	#ifndef INCLUDE_GUARDS_value_category_tester_HPP
